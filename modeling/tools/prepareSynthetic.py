import sys 
import os 
import json
import numpy as np 
from random import randint

try:
    from modeling import *
    from openalea.plantgl.all import *
except ImportError:
    print("-> Please install the \033[1;32;40m modeling, \033[1;34;40m openalea and \033[1;36;40mMAppleT \033[0;37;40m packages")

class prepareSynthetic(object):
    """
    prepareSynthetic

    It is a class that allows you to do some basic processing of the plantGL's trees 
    generated by the MAppleT model, and also help you to prepre this data to fit the 
    Pointnet++ and P2Pnet networks
    """

    def __init__(self, scene=None):
        self._leafs = 0
        self._apple = 0
        self._brach = 0

    def get_singleOrgan(self, MAT_PGL_scene, str_organ, action=0):
        """
        INPUT:
            MAT_PGL_scene = MappleT's PlantGL scene
            str_organ = String with the possible element to return 
                    'wood' -> Return the trunk and branches of the syntetic tree
                    'apple'-> Return the available apples
                    'leaf' -> Return the available leafs 
            action = 
                    0 -> return apples
                    1 -> Remove apples 
        OUPUT:
            PlantGL scene with just the tree's leafs
        """
        # Init var
        scn2ret = Scene()
        organ = self.get_Definition(str_organ)
        # Walk over the shapes of the scene 
        for shape in MAT_PGL_scene:
            # Verify the Obj primitive
            if(action == 0):        
                if isinstance(get_geometry(shape), organ):
                    scn2ret.add( shape )
            elif(action == 1):
                if not isinstance(get_geometry(shape), organ):
                    scn2ret.add( shape )
        return scn2ret 

    def get_Definition(self, str_Organ):
        """
        INPUT:
            str_Organ: String with the possible element to return 
                    'wood' -> Return the trunk and branches of the syntetic tree
                    'apple'-> Return the available apples
                    'leaf' -> Return the available leafs 
        OUTPUT:
            Object type that represent the desired organ in plantGL
        """
        if(str_Organ.lower() == "wood"):
            return Cylinder
        elif(str_Organ.lower() == "apple"):
            return Sphere
        elif(str_Organ.lower() == "leaf"):
            return BezierPatch
        else:
            raise IOError("Unexpected value")

    def removeTextFromScene(self, scenePlantGl):
        """
        INPUT:
            scenePlantGl = Scene of plantGL
        OUPUT:
            PlantGL scene without text 
        """
        # Init var
        scn2ret = Scene()
        # Walk over the available Scene's shapes
        for shape in scenePlantGl:
            if(shape.id != 0):
                scn2ret.add(shape)
        return scn2ret

    def preparePts(self, LstPointCloudScenes ):
        """
        INPUT:
            LstPointCloudScenes: List of points from the same scene
        OUTPUT:
            Dictionary with the data to write, the levels of the dict are as follows:
                [0] -> PointCloud: numpy array
                [1] -> Skeleton  : numpy array
                [2] -> LabeledPC : numpy array  
        """
        # Init var 
        dict2ret = dict()
        ptsList = []
        cntr = 0
        # Verify that the element is a list 
        if(isinstance( LstPointCloudScenes, list )):
            # Walk over the list 
            for scene in LstPointCloudScenes:
                # Get the points from the actual sytetic poitcloud 
                npPoints = np.array( scene.pointList )
                #  Verify that the points are in the 3D space
                if( npPoints.shape[1] == 3 ):
                    # Save the point cloud in a serialisabel way
                    for i in range( npPoints.shape[0] ):
                        # List
                        ptsList.append( list(  npPoints[i]  ) )
                    if( cntr==0 and "PointCloud" not in dict2ret.keys() ):
                        dict2ret["PointCloud"] = ptsList
                    elif( cntr==1 and "Skeleton" not in dict2ret.keys() ):
                        dict2ret["Skeleton"] = ptsList
                    elif( cntr == 2 and "LabeledPC" not in dict2ret.keys() ):
                        dict2ret["LabeledPC"] = ptsList
                    else:
                        pass
                    # Prepare variable for the next inter 
                    ptsList = []
                    cntr += 1
                else:
                    raise IOError("The points must be in the 3D space (N,3)")
        else:
            raise IOError("Unexpected variable type")
        return dict2ret

    def color_basicDict(self, lstNames):
        """
        INPUT:
            lstNames: Name list of the available elements in the scene
        OUTPUT:
            Python dictionary:
                -> ShapeName: OpenGL Color
        """
        # init vat
        autoColor = {}
        cntr = 0
        # Create a list of materials --- define the color 
        red = Material((255, 0, 0))
        gre = Material((0, 255, 0))
        blu = Material((0, 0, 255))
        colorList = [red, gre, blu]
        # Walk over the list ans asiign the color 
        for i in lstNames:
            if i not in autoColor.keys():
                autoColor[i] = colorList[cntr]
                cntr += 1
            if(cntr > 2):
                cntr = 0
        return autoColor 

    def get_SyntLabelOrgans(self, scenePlantGl ):
        """
        INPUT:
            scenePlantGl = Scene of plantGL
        OUPUT:
            Point cloud labled scene
        """       
        # Init var
        cl_scene = Scene()
        # Get the availabla elements in the scene 
        lstScnEle = self.get_SceneList(scenePlantGl)
        # Get the autoclor elements  
        d_aColor = self.color_basicDict( lstScnEle )
        # Change the predefined color of every element to the desired for 
        # the labelization of the point cloud 
        for shape in scenePlantGl:
            # Type of the shape 
            sh_name = type( get_geometry( shape ) )
            # Get the color name for the type fo the geometry 
            a_color = d_aColor[sh_name]
            # Add the shape with the color modification 
            cl_scene.add( Shape(shape.geometry,
                                a_color,
                                shape.id,
                                shape.parentId) )
        # Get the point cloud from the scene 
        labeledOrgan = lidarscan( cl_scene ) 
        return labeledOrgan

    def get_SceneList(self, scenePlantGl):
        """
        INPUT: 
            scenePlantGl = PlantGL scene with the MappleT model inside
        OUTPUT:
            Python list that contain the string names of the shape inside the scene
        """
        lst2ret = []
        for shape in scenePlantGl:
            geom = type(get_geometry(shape))
            if( geom not in lst2ret ):
                lst2ret.append( geom )
            else:
                pass
        return lst2ret